#' Explore Area of Applicability
#'
#' @description
#' This function lets the user explore an calculated Area of Applicability object
#' interactively in an R shiny application. Depending on whether the parameter \code{LPD = TRUE}
#' was specified in the calculation of the \code{AOA}, the user can either explore the
#' \code{AOA} and \code{DI} layer or additionally explore the \code{LPD} and a reactive \code{neighbor-dependent
#' AOA layer}.
#' The functionality is very suitable for a first visual interpretation of the
#' Area of Applicability.
#'
#' @param aoa An R object of class \code{aoa} (generated by the \code{\link{aoa}} function).
#'
#' @details
#' Interpretation of results: If a location is very similar to the properties
#' of the training data it will have a low distance in the predictor variable space
#' (\code{DI} towards 0) while locations that are very different in their properties
#' will have a high \code{DI}.
#' Depending on a threshold for the DI, the location will either be classified as
#' \code{Inside AOA (1)} or \code{Outside AOA (0)}. The comparison is done for the nearest neighbor
#' of the training points in the predictor space. This can be seen in the \code{AOA} layer.
#' The \code{LPD} (Local Data Point Density) layer indicates the total number of training data points
#' for which the locations \code{DI} is smaller than the threshold, i.e. on how many similar training points the model was trained.
#' The fourth layer is based on the \code{LPD} layer and can be seen as a \code{neighbor-dependet AOA}. This layer extends the \code{AOA}
#' by a minimum number k of training data points for which the threshold condition must hold in order to be classified as \code{Indside AOA (1)}.
#'
#' @import terra leaflet shiny shinyWidgets shinycssloaders bslib rlist sf ggplot2 plotly viridis
#'
#' @author
#' Fabian Schumacher
#' @references Meyer, H., Pebesma, E. (2021): Predicting into unknown space?
#' Estimating the area of applicability of spatial prediction models.
#' Methods in Ecology and Evolution 12: 1620-1633. \doi{10.1111/2041-210X.13650}

#' @examples
#' \dontrun{
#'
#' }
#' @export exploreAOA
#' @aliases exploreAOA


###################
# Define Function # ------------------------------------------------------------
###################

exploreAOA <- function(aoa) {
  ########################
  # Check function input # -----------------------------------------------------
  ########################

  # check for class 'aoa'_______________________________________________________
  if (!inherits(aoa, "aoa")) {
    stop("Your passed data is not of class 'aoa'")
  }


  #############
  # Load data # ----------------------------------------------------------------
  #############

  # define raster layers and layer names _______________________________________
  message("Loading data...")
  LPD_available <- "LPD" %in% names(aoa)
  parameters <- aoa$parameters
  rasterImages <- c()
  rasterImages$AOA <- project(aoa$AOA, "epsg:4326")
  rasterImages$DI <- project(aoa$DI, "epsg:4326")
  if (LPD_available) {
    rasterImages$LPD <- project(aoa$LPD, "epsg:4326")
    rasterImages$AOA_LPD <- project(aoa$AOA, "epsg:4326") # initialize with AOA
    layerNames <-
      c(
        "AOA" = "AOA",
        "DI" = "DI",
        "LPD" = "LPD",
        "AOA (LPD-dependent)" = "AOA_LPD"
      )
  } else {
    layerNames <- c("AOA", "DI")
  }

  # define legend props for the AOA, DI and LPD ________________________________
  legendProperties <- list(
    AOA = list(
      pal = NULL,
      colors = c("#fdb138", "#025196"),
      labels = c("Outside (0)", "Inside (1)"),
      values = as.numeric(values(rasterImages$AOA)),
      title = "AOA"
    ),
    DI = list(
      pal = colorNumeric(palette = "viridis",
                         domain = as.numeric(values(rasterImages$DI))),
      colors = viridis(30),
      labels = NULL,
      values = as.numeric(values(rasterImages$DI)),
      title = "DI"
    )
  )
  if (LPD_available) {
    legendProperties <- list.append(
      legendProperties,
      LPD = list(
        pal = colorNumeric(palette = "viridis",
                           domain = as.numeric(values(
                             rasterImages$LPD
                           ))),
        colors = viridis(30),
        labels = NULL,
        values = as.numeric(values(rasterImages$LPD)),
        title = "LPD"
      )
    )
    legendProperties <- list.append(
      legendProperties,
      AOA_LPD = list(
        pal = NULL,
        colors = c("#fdb138", "#025196"),
        labels = c("Outside (0)", "Inside (1)"),
        values = as.numeric(values(rasterImages$AOA)),
        title = "AOA (LPD-dependent)"
      )
    )
  }


  # define model props and build data.frame from model props____________________
  message("Extracting model properties...")
  if (LPD_available) {
    if (!is.null(parameters$avrgLPD)) {
      avrgLPD <- parameters$avrgLPD
    } else {
      avrgLPD <- NA
    }
    maxLPD <- parameters$maxLPD
    if (parameters$maxLPD < max(values(rasterImages$LPD, na.rm = T))) {
      maxLPD <- parameters$maxLPD
    } else {
      maxLPD <- max(values(rasterImages$LPD, na.rm = T))
    }
  }
  parameters <-
    c(c(parameters$threshold),
      c(parameters$scaleparam$dim[1]),
      c(parameters$method))

  rownames <- c()
  if (LPD_available) {
    parameters <- append(parameters, c(maxLPD), 2)
    parameters <- append(parameters, c(avrgLPD), 3)
    rownames <-
      c("DI threshold",
        "Sample size",
        "Max. LPD",
        "Avrg trainLPD",
        "Distance method")
  } else {
    rownames <- c("DI threshold", "Sample size", "Distance method")
  }

  parameters_df <- data.frame(parameters)
  row.names(parameters_df) <- rownames

  parameters_df["DI threshold",] <-
    round(as.numeric(parameters_df["DI threshold",]), digits = 3)
  parameters_df["Sample size",] <-
    as.integer(parameters_df["Sample size",])
  if (parameters_df["Distance method",] == "L2") {
    parameters_df["Distance method",] <- "Euclidian Distance"
  } else if (parameters_df["Distance method",] == "MD") {
    parameters_df["Distance method",] <- "Mahalanobis Distance"
  }
  if (LPD_available) {
    parameters_df["Max. LPD",] <-
      as.integer(parameters_df["Max. LPD",])
    parameters_df["Avrg trainLPD",] <-
      as.integer(parameters_df["Avrg trainLPD",])
  }


  # define layer extend ________________________________________________________
  extent <- ext(rasterImages$AOA)
  xmin <- as.numeric(extent[1])
  xmax <- as.numeric(extent[2])
  ymin <- as.numeric(extent[3])
  ymax <- as.numeric(extent[4])


  # define marker icon _________________________________________________________
  xmark <-
    makeIcon(
      system.file("images", "xmark.png", package = "CAST"),
      iconWidth = 18,
      iconHeight = 18
    )

  light <- bs_theme(bootswatch = "yeti")
  dark <- bs_theme(bootswatch = "yeti", bg = "#333", fg = "#fff")

  link_github <- tags$a(shiny::icon("github"), "CAST - exploreAOA", href = "https://github.com/fab-scm/CAST/blob/master/R/exploreAOA.R", target = "_blank")



  #############
  # Define UI # ----------------------------------------------------------------
  #############

  message("Building UI...")
  ui <- page_navbar(
    tags$style(
      ".nomargin .form-group { margin-bottom: 0px; } #pixelValues .table { margin-bottom: 0px; }"
    ),
    title = "Explore AOA",
    theme = light,
    padding = "0",
    nav_panel(
      title = "Map",
      icon = icon("map"),
      layout_sidebar(
        sidebar = sidebar(
          position = "left",
          width = 400,
          open = "always",
          selectInput("layerSelect", "Layer",
                      layerNames),
          sliderInput(
            "opacity",
            "Opacity",
            min(0),
            max(1),
            value = 1,
            step = 0.01
          ),
          downloadButton("downloadTiff", "Download GeoTiff"),
          if (LPD_available) {
            conditionalPanel(
              condition = "input.layerSelect == 'AOA_LPD'",
              tags$hr(style = "border: 1px solid #ccc; width: 100%;"),
              sliderInput(
                "k",
                "Min. LPD",
                min(1),
                max(maxLPD),
                value = 1,
                step = 1
              )
            )
          },
          tags$hr(style = "border: 1px solid #ccc; width: 100%;"),
          fileInput(
            "trainLocations",
            label = "Upload your training locations",
            multiple = FALSE,
            accept = c(".geojson", ".gpkg")
          ),
          conditionalPanel(
            condition = "output.uploadHappened == 'yes'",
            tags$div(class = "nomargin", checkboxInput("showTrainDat", "Show training locations"))
          ),
          tags$hr(style = "border: 1px solid #ccc; width: 100%;"),
          tags$h5(style = "font-weight: bold;", "Model Props:"),
          tableOutput("modelProps"),
        ),
        class = "p-0 gap-0",
        leafletOutput(outputId = "map",
                      height = "100vh"),
        conditionalPanel(condition = "output.showPanel == 'clicked'",
                         absolutePanel(
                           bottom = 40,
                           left = 10,
                           width = 170,
                           draggable = TRUE,
                           card(card_header("Pixel values"),card_body(tableOutput("pixelValues"), padding = "4px"))
                         ))
      )
    ),
    nav_spacer(),
    nav_item(tags$div(class = "nomargin", switchInput(inputId = "dark_mode", value = FALSE, label = icon("moon"), width = "auto", size = "small", inline = TRUE))),
    nav_menu(
      title = "Links",
      nav_item(link_github),
      align = "right"
    )
  )


  #################
  # Define server # ------------------------------------------------------------
  #################

  message("Building server...")
  server <- function(input, output, session) {

    # define reactive values ___________________________________________________
    rv <- reactiveValues(
      map = NULL,
      clickOccurred = "not clicked",
      AOA_LPD = rasterImages$AOA_LPD,
      # plot1 = NULL,
      # plot2 = NULL,
      uploadHappened = "no"
    )


    # theme handling ___________________________________________________________
    observe(session$setCurrentTheme(
      if (isTRUE(input$dark_mode)) dark else light
    ))

    # define leaflet map outout ________________________________________________
    output$map <- renderLeaflet({
      rv$map <-
        leaflet(options = leafletOptions(minZoom = 2, maxZoom = 19)) %>%
        addTiles(group = "OSM") %>%
        addProviderTiles(providers$Esri, group = "Esri") %>%
        addProviderTiles(providers$Esri.WorldGrayCanvas, group = "Esri World Gray Canvas") %>%
        addProviderTiles(providers$Esri.WorldImagery, group = "Esri World Imagery") %>%
        setMaxBounds(
          lng1 = xmin - 180,
          # Minimum longitude
          lat1 = ymin - 90,
          # Minimum latitude
          lng2 = xmax + 180,
          # Maximum longitude
          lat2 = ymax + 90     # Maximum latitude
        ) %>%
        fitBounds(
          lng1 = xmin,
          lat1 = ymin,
          lng2 = xmax,
          lat2 = ymax
        ) %>%
        addScaleBar(position = "bottomleft")
      rv$map
    })


    # raster layer image handling ______________________________________________
    observe({
      if (!is.null(rv$map) &&
          !is.null(rasterImages[[input$layerSelect]])) {
        showPageSpinner()
        layerLegendProps <- legendProperties[[input$layerSelect]]
        if (input$layerSelect == "AOA_LPD") {
          rasterImages$AOA_LPD[rasterImages$LPD < input$k] <- 0
          rasterImages$AOA_LPD[rasterImages$LPD >= input$k] <- 1
          rv$AOA_LPD <- rasterImages$AOA_LPD
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(rv$AOA_LPD,
                           colors = layerLegendProps$colors,
                           opacity = input$opacity,
                           group = "Raster") %>%
            addLegend(
              position = "bottomright",
              colors = layerLegendProps$colors,
              labels = layerLegendProps$labels,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            ) %>%
            addLayersControl(
              baseGroups = c("OSM", "Esri", "Esri World Gray Canvas", "Esri World Imagery"),
              overlayGroups = c("Raster"),
              options = layersControlOptions(position = "topleft")
            )
        }
        if (is.null(layerLegendProps$pal)) {
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(rasterImages[[input$layerSelect]],
                           colors = layerLegendProps$colors,
                           opacity = input$opacity,
                           group = "Raster") %>%
            addLegend(
              position = "bottomright",
              colors = layerLegendProps$colors,
              labels = layerLegendProps$labels,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            ) %>%
            addLayersControl(
              baseGroups = c("OSM", "Esri", "Esri World Gray Canvas", "Esri World Imagery"),
              overlayGroups = c("Raster"),
              options = layersControlOptions(position = "topleft")
            )
        } else {
          leafletProxy("map") %>%
            clearImages() %>%
            clearControls() %>%
            addRasterImage(rasterImages[[input$layerSelect]],
                           colors = layerLegendProps$colors,
                           opacity = input$opacity,
                           group = "Raster") %>%
            addLegend(
              position = "bottomright",
              pal = layerLegendProps$pal,
              values = layerLegendProps$values,
              title = layerLegendProps$title,
              opacity = 1
            ) %>%
            addLayersControl(
              baseGroups = c("OSM", "Esri", "Esri World Gray Canvas", "Esri World Imagery"),
              overlayGroups = c("Raster"),
              options = layersControlOptions(position = "topleft")
            )
        }
        hidePageSpinner()
      }
    })


    # handling of training location upload _____________________________________
    observeEvent(input$trainLocations, {
      rv$uploadHappened <- "yes"
      updateCheckboxInput(session, "showTrainDat", value = TRUE)
    })

    output$uploadHappened <- reactive({
      rv$uploadHappened
    })
    outputOptions(output, "uploadHappened", suspendWhenHidden = FALSE)

    observeEvent(input$showTrainDat, {
      if (input$showTrainDat == TRUE && rv$uploadHappened == "yes") {
        # Read the uploaded GeoJSON/GeoPackage file
        trainLocations <- st_read(input$trainLocations$datapath)
        trainLocations <- as_Spatial(trainLocations)

        # Add the GeoJSON data to the Leaflet map
        leafletProxy("map") %>%
          addCircleMarkers(
            data = trainLocations,
            group = "trainLocations",
            color = "#ff3535",
            stroke = TRUE,
            fillColor = "white",
            radius = 3,
            fillOpacity = 10
          )
      } else if (input$showTrainDat == FALSE &&
                 rv$uploadHappened == "yes") {
        leafletProxy("map") %>%
          clearGroup(group = "trainLocations")
      }
    })


    # render model props table _________________________________________________
    output$modelProps <- renderTable({
      return(parameters_df)
    },
    width = "100%",
    align = "lr",
    rownames = TRUE,
    colnames = FALSE,
    striped = TRUE)


    # map click handling _______________________________________________________
    observeEvent(input$map_click, {
      rv$clickOccurred <- "clicked"
      click <- input$map_click
      lng <- click$lng
      lat <- click$lat

      leafletProxy("map") %>%
        removeMarker(layerId = c("xmark")) %>%
        addMarkers(
          layerId = "xmark",
          lng = lng,
          lat = lat,
          icon = xmark
        )
    })

    output$showPanel <- reactive({
      rv$clickOccurred
    })
    outputOptions(output, "showPanel", suspendWhenHidden = FALSE)

    output$pixelValues <- renderTable({
      click <- input$map_click
      if (is.null(click)) {
        return()
      }

      # get coordinates from click event
      lng <- click$lng
      lat <- click$lat

      # extract raster values
      AOA_value <- as.numeric(terra::extract(rasterImages$AOA,
                                             cbind(lng, lat)))
      DI_value <- as.numeric(round(terra::extract(rasterImages$DI,
                                                  cbind(lng, lat)),2))
      if (LPD_available) {
        LPD_value <- as.numeric(terra::extract(rasterImages$LPD,
                                               cbind(lng, lat)))
        AOA_LPD_value <- as.numeric(terra::extract(rv$AOA_LPD,
                                                   cbind(lng, lat)))
      }

      values_df <- c(c(AOA_value), c(DI_value))
      if (LPD_available) {
        values_df <- c(values_df, c(LPD_value), c(AOA_LPD_value))
        rownames <- c("AOA", "DI", "LPD", "AOA_LPD")
      } else {
        rownames <- c("AOA", "DI")
      }

      # convert to df
      values_df <- data.frame(values_df)
      rownames(values_df) <- rownames

      # format AOA values for table output
      if (is.na(values_df["AOA",])) {
        values_df["AOA",] <- values_df["AOA",]
      } else if (as.integer(values_df["AOA",]) == 0) {
        values_df["AOA",] <- "Outside"
      } else if (as.integer(values_df["AOA",]) == 1) {
        values_df["AOA",] <- "Inside"
      }

      if (LPD_available) {
        # format AOA_LPD values for table output
        if (is.na(values_df["AOA_LPD",])) {
          values_df["AOA_LPD",] <- values_df["AOA_LPD",]
        } else if (as.integer(values_df["AOA_LPD",]) == 0) {
          values_df["AOA_LPD",] <- "Outside"
        } else if (as.integer(values_df["AOA_LPD",]) == 1) {
          values_df["AOA_LPD",] <- "Inside"
        }
        values_df["LPD",] <- as.integer(values_df["LPD",])
      }

      if (!is.na(values_df["AOA",])) {
        return(values_df)
      } else {
        return("NA")
      }
    },
    width = "100%",
    align = "lr",
    rownames = TRUE,
    colnames = FALSE,
    striped = TRUE,
    hover = TRUE)

    # download handler _________________________________________________________
    output$downloadTiff <- downloadHandler(
      filename = function() {
        paste0(input$layerSelect, ".tif")
      },
      content = function(file) {
        # Generate and save your TIFF data to the file
        if (input$layerSelect == "AOA_LPD") {
          layer <- rv$AOA_LPD
        } else {
          layer <- rasterImages[[input$layerSelect]]
        }
        # layer <- rasterImages[[input$layerSelect]]
        writeRaster(layer, filename = file)
      }
    )

  }



  ###############################
  # Create the Shiny app object # ----------------------------------------------
  ###############################

  message("Starting Shiny app...")
  shinyApp(ui = ui, server = server, options = list(launch.browser = TRUE))
}
